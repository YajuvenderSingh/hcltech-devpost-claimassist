AWSTemplateFormatVersion: '2010-09-09'
Description: 'Document Classification Lambda Function for NMM Worker Compensation Documents'

Parameters:
  FunctionName:
    Type: String
    Default: 'nmm_document_classification_lambda'
    Description: 'Name for the Lambda function'
  
  IAMRoleName:
    Type: String
    Default: 'HCL-User-Role-Aiml-lambda'
    Description: 'IAM role name (must be created separately)'
  
  SQSQueueArn:
    Type: String
    Description: 'ARN of the SQS queue for post-extraction processing'
  
  EntityExtractionLambdaName:
    Type: String
    Default: 'nmm_entityextraction_lambda'
    Description: 'Name of the entity extraction Lambda function'

Resources:
  # DynamoDB Table for Document Extraction (if not exists)
  ExtractionTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: nmm-doc-extraction
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: docid
          AttributeType: S
      KeySchema:
        - AttributeName: docid
          KeyType: HASH
      StreamSpecification:
        StreamViewType: NEW_AND_OLD_IMAGES
      Tags:
        - Key: Purpose
          Value: DocumentExtraction
        - Key: System
          Value: ClaimAssist

  # DynamoDB Table for Dashboard (if not exists)
  DashboardTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: nmm-dashboard
      BillingMode: PAY_PER_REQUEST
      AttributeDefinitions:
        - AttributeName: docid
          AttributeType: S
      KeySchema:
        - AttributeName: docid
          KeyType: HASH
      Tags:
        - Key: Purpose
          Value: Dashboard
        - Key: System
          Value: ClaimAssist

  # Lambda Function
  DocumentClassificationLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Ref FunctionName
      Runtime: python3.9
      Handler: lambda_function.lambda_handler
      Role: !Sub 'arn:aws:iam::${AWS::AccountId}:role/${IAMRoleName}'
      Code:
        ZipFile: |
          import json
          import boto3
          from utility import get_docs_extract, get_prompt_ready, execute_model, upsert_dashboard_record

          def lambda_handler(event, context):
              try:
                  print("Event - ", event)
                  data_string = event['Records'][0]['body']
                  print("event[body]",data_string,type(data_string))
                  
                  if type(data_string) is dict:
                      qtext = data_string
                  else:
                      qtext = json.loads(data_string)
                  
                  print("qtext=json.loads(data_string) :",type(qtext),qtext)
                  s3files = [qtext['s3filename']]
                  indexid = qtext['indexid']
                  print("indexid = ",indexid)
                  docid = qtext['docid']
                  print("docid = ",docid)

                  if not docid:
                      print("Error: docid is not present, hence returning")
                      return {
                          'statusCode': 400,
                          'body': json.dumps({'error': 'docid is required'})
                      }
                  
                  # Initialize Bedrock client
                  bedrock = boto3.client('bedrock-runtime')
                  print("bedrock - ", bedrock)
                  
                  # Get document extract details
                  docs_extract_details = get_docs_extract(docid)
                  print("docs_extract_details - ", docs_extract_details)
                  
                  if 'Item' not in docs_extract_details:
                      return {
                          'statusCode': 404,
                          'body': json.dumps({'error': 'Document not found for docid'})
                      }
                  
                  # Extract document data
                  document_name = docs_extract_details["Item"]["document_name"]
                  rawtext = docs_extract_details["Item"]["rawtext"]
                  tbltxt = docs_extract_details["Item"]["tbltxt"]
                  keyvaluesText = docs_extract_details["Item"]["keyvaluesText"]
                  
                  # Language detection and translation
                  translate_client = boto3.client('translate')
                  comprehend_client = boto3.client('comprehend')
                  translated_text=""
                  
                  language_response = comprehend_client.detect_dominant_language(Text=rawtext)
                  detected_language = language_response['Languages'][0]['LanguageCode']
                  print("detected language = ", detected_language)
                  doc_language = "English"
                  
                  if detected_language == 'en':
                      doc_language = "English"
                      print("detected lang is english")
                  else:
                      translation_response = translate_client.translate_text(
                          Text=rawtext,
                          SourceLanguageCode=detected_language,
                          TargetLanguageCode='en'
                      )
                      doc_language = "Spanish"
                      translated_text = translation_response['TranslatedText']
                      resTanslate = upsert_dashboard_record('nmm-doc-extraction', docid=docid, translated_text=translated_text)
                      print ("resTanslate = ", resTanslate)
                      print("translated_text = ", translated_text)

                  # Generate prompt and classify document
                  if detected_language == 'en':
                      prompt = get_prompt_ready(str(rawtext), str(tbltxt), str(keyvaluesText))
                  else:
                      prompt = get_prompt_ready(str(translated_text), "", "")
                      
                  classification_result = execute_model(prompt, bedrock)
                  
                  # Parse classification result
                  llm_extracted_json = json.loads(classification_result)
                  classificationtype = llm_extracted_json['classification_type']
                  
                  # Update tables
                  resExtraction = upsert_dashboard_record('nmm-doc-extraction', docid=docid, classification=classificationtype)
                  print ("resExtraction = ", resExtraction)

                  if "ResponseMetadata" in resExtraction:
                      if "HTTPStatusCode" in resExtraction["ResponseMetadata"]:
                          print("@@@HTTP Response Code of resExtraction = ", resExtraction["ResponseMetadata"]["HTTPStatusCode"])
                          
                          if resExtraction["ResponseMetadata"]["HTTPStatusCode"] == 200:
                              print("success to call next dashboard")
                              restDashboard = upsert_dashboard_record('nmm-dashboard', docid=docid, classification_status="Completed", classification=classificationtype, doc_language=doc_language, s3filename=s3files)
                              print ("restDashboard = ", restDashboard)
                              
                              if "ResponseMetadata" in restDashboard:
                                  if "HTTPStatusCode" in restDashboard["ResponseMetadata"]:
                                      print("@@@HTTP Response Code of restDashboard = ", restDashboard["ResponseMetadata"]["HTTPStatusCode"])

                                      if restDashboard["ResponseMetadata"]["HTTPStatusCode"] == 200:
                                          print("success to call entity extraction lambda  ")
                                          
                                          try:
                                              lambda_client = boto3.client('lambda')
                                              function_name = "nmm_entityextraction_lambda"
                                              response = lambda_client.invoke(
                                                  FunctionName=function_name,
                                                  InvocationType='RequestResponse',
                                                  Payload=json.dumps(event)
                                              )
                                              print("lambda invoke response = ", response)

                                          except Exception as e:
                                              print(f"Error invoking Entity Extraction Lambda function: {e}")

                  return {
                      'statusCode': 200,
                      'body': json.dumps({
                          'docid': docid,
                          'classification_type': classificationtype,
                          'status': 'Classification completed successfully'
                      })
                  }
                  
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': str(e)})
                  }
      Environment:
        Variables:
          EXTRACTION_TABLE: !Ref ExtractionTable
          DASHBOARD_TABLE: !Ref DashboardTable
          ENTITY_EXTRACTION_LAMBDA: !Ref EntityExtractionLambdaName
      Timeout: 300
      MemorySize: 512
      Description: 'Document classification for New Mexico Mutual worker compensation documents'

  # Event Source Mapping (SQS to Lambda)
  SQSEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !Ref SQSQueueArn
      FunctionName: !Ref DocumentClassificationLambda
      BatchSize: 10
      MaximumBatchingWindowInSeconds: 0
      Enabled: true

Outputs:
  LambdaFunctionArn:
    Description: 'ARN of the Lambda function'
    Value: !GetAtt DocumentClassificationLambda.Arn
    Export:
      Name: !Sub '${AWS::StackName}-LambdaArn'
  
  ExtractionTableName:
    Description: 'Name of the extraction table'
    Value: !Ref ExtractionTable
    Export:
      Name: !Sub '${AWS::StackName}-ExtractionTable'
  
  DashboardTableName:
    Description: 'Name of the dashboard table'
    Value: !Ref DashboardTable
    Export:
      Name: !Sub '${AWS::StackName}-DashboardTable'
